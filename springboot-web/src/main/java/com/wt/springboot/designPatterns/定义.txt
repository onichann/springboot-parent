创建型
    -单例模式（Singleton Pattern）
    -工厂模式（Factory Pattern） （Abstract Factory Pattern）
    -原型模式（Prototype Pattern）
    -生成器模式/建造者模式（Builder Pattern）
结构型
    -适配器模式（Adapter Pattern）
    -装饰者模式（Decorator Pattern）
    -代理模式（Proxy Pattern）
    -外观模式（Facade Pattern）
    -桥接模式（Bridge Pattern）
    -组合模式（Composite Pattern）
    -过滤器模式（Filter、Criteria Pattern）
    -享元模式（Flyweight Pattern）
行为型模式
    -责任链模式（Chain of Responsibility Pattern）
    -命令模式（Command Pattern）*
    -解释器模式（Interpreter Pattern）  --麻烦，特别少用
    -迭代器模式（Iterator Pattern）
    -中介者模式（Mediator Pattern）notice
    -备忘录模式（Memento Pattern）*
    -观察者模式（Observer Pattern）
    -状态模式（State Pattern）
    -空对象模式（Null Object Pattern）
    -策略模式（Strategy Pattern）
    -模板模式（Template Pattern）
    -访问者模式（Visitor Pattern）




*单例模式--是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。
通过单例模式可以保证系统中一个类只有一个实例。即一个类只有一个对象实例。

*工厂模式--是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。

工厂模式根据抽象程度的不同分为三种：

简单工厂模式（也叫静态工厂模式）

工厂方法模式（也叫多形性工厂）

抽象工厂模式（也叫工具箱）

*原型模式--通过复制现有的对象实例来创建新的对象实例。

*生成器模式--将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
生成器模式利用一个导演者对象和具体建造者对象一个一个地建造出所有的零件，从而建造出完整的对象。

四个要素：

        Builder：生成器接口，定义创建一个Product对象所需要的各个部件的操作。

        ConcreteBuilder：具体的生成器实现，实现各个部件的创建，并负责组装Product对象的各个部件，同时还提供一个让用户获取组装完成后的产品对象的方法。

        Director：指导者，也被称导向者，主要用来使用Builder接口，以一个统一的过程来构建所需要的Product对象。

        Product：产品，表示被生成器构建的复杂对象，包含多个部件。
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

*适配器模式--将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

*装饰者模式--在不必改变原类文件和原类使用的继承的情况下，动态地扩展一个对象的功能。

            它是通过创建一个包装对象，也就是用装饰来包裹真实的对象来实现。

            角色：

                抽象构件角色（Project）：给出一个接口，以规范准备接收附加责任的对象。

                具体构件角色（Employe）：定义一个将要接收附加责任的类。

                装饰角色（Manager）：持有一个构件对象的实例，并定义一个与抽象构件接口一致的接口。

                具体装饰角色（ManagerA、ManagerB）：负责给构件对象“贴上”附加的责任。
*代理模式--为其他对象提供一种代理以控制对这个对象的访问。
在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用

角色：

1，  抽象角色：声明真实对象和代理对象的共同接口。

2，  代理角色：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，
    附加其他的操作，相当于对真实对象进行封装。

3，  真实角色：代理角色所代表的真实对象，是我们最终要引用的对象。


*外观模式--为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用


外观模式总结：

1、外观模式为复杂子系统提供了一个简单接口，并不为子系统添加新的功能和行为。

2、外观模式实现了子系统与客户端之间的松耦合关系。

3、外观模式没有封装子系统的类，只是提供了简单的接口。 如果应用需要，它并不限制客户使用子系统类。因此可以灵活的在系统易用性与通用性之间选择。

4、外观模式注重的是简化接口，它更多的时候是从架构的层次去看整个系统，而并非单个类的层次。

*桥接模式--将抽象部分与实现部分分离，使它们都可以独立的变化。

*组合模式--又叫做部分-整体模式,它使我们树型结构的问题中,模糊了简单元素和复杂元素的概念,
客户程序可以向处理简单元素一样来处理复杂元素,从而使得客户程序与复杂元素的内部结构解藕. e.g. DelegatingWebMvcConfiguration-WebMvcConfigurerComposite
组成部分：
Component: 为参加组合的对象声明一个公共接口, 不管是组合还是叶结点.
Leaf: 在组合中表示叶子结点对象,叶子结点没有子结点.
Composite: 表示参加组合的有子对象的对象, 并给出树枝购件的行为.

*过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）--是一种设计模式，这种模式允许开发人员使用不同的标准来**过滤一组对象**，
通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。

*享元模式--（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。
这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。
享元模式以共享的方式高效地支持大量的细粒度对象。

享元模式的结构

　　 享元模式采用一个共享来避免大量拥有相同内容对象的开销。这种开销最常见、最直观的就是内存的损耗。享元对象能做到共享的关键是区分内蕴状态(Internal State)和外蕴状态(External State)。

        一个内蕴状态是存储在享元对象内部的，并且是不会随环境的改变而有所不同。因此，一个享元可以具有内蕴状态并可以共享。

　　 一个外蕴状态是随环境的改变而改变的、不可以共享的。享元对象的外蕴状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。外蕴状态不可以影响享元对象的内蕴状态，
    它们是相互独立的。

　　 享元模式可以分成单纯享元模式和复合享元模式两种形式。

如何解决：用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。

关键代码：用 HashMap 存储这些对象。

在单纯的享元模式中，所有的享元对象都是可以共享的。

单纯享元模式所涉及到的角色如下：

抽象享元(Flyweight)角色 ：给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。

具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。

享元工厂(FlyweightFactory)角色 ：本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，
享元工厂角色会检查系统中是否已经有一个符合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个合适的享元对象。


在单纯享元模式中，所有的享元对象都是单纯享元对象，也就是说都是可以直接共享的。还有一种较为复杂的情况，将一些单纯享元使用合成模式加以复合，形成复合享元对象。这样的复合享元对象本身不能共享，
但是它们可以分解成单纯享元对象，而后者则可以共享。

从运行结果可以看出，一个复合享元对象的所有单纯享元对象元素的外蕴状态都是与复合享元对象的外蕴状态相等的。即外运状态都等于Composite Call。

从运行结果可以看出，一个复合享元对象所含有的单纯享元对象的内蕴状态一般是不相等的。即内蕴状态分别为b、c、a。

从运行结果可以看出，复合享元对象是不能共享的。即使用相同的对象compositeState通过工厂分别两次创建出的对象不是同一个对象。

从运行结果可以看出，单纯享元对象是可以共享的。即使用相同的对象state通过工厂分别两次创建出的对象是同一个对象。

享元模式的优缺点

        享元模式的优点在于它大幅度地降低内存中对象的数量。但是，它做到这一点所付出的代价也是很高的：

享元模式使得系统更加复杂。为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。

享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

*责任链模式--定义：使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，
直到有对象处理它为止。

责任链模式的结构

        责任链模式的类图非常简单，它由一个抽象地处理类和它的一组实现类组成：

抽象处理类：抽象处理类中主要包含一个指向下一处理类的成员变量nextHandler和一个处理请求的方法handRequest，handRequest方法的主要主要思想是，如果满足处理的条件，
则有本处理类来进行处理，否则由nextHandler来处理。

具体处理类：具体处理类主要是对具体的处理逻辑和处理的适用条件进行实现。

总结

       责任链模式其实就是一个灵活版的if…else…语句，它就是将这些判定条件的语句放到了各个处理类中，这样做的优点是比较灵活了，但同样也带来了风险，
       比如设置处理类前后关系时，一定要特别仔细，搞对处理类前后逻辑的条件判断关系，并且注意不要在链中出现循环引用的问题。

*命令模式--定义：将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。

命令模式的适用场景

       对于大多数请求-响应模式的功能，比较适合使用命令模式，正如命令模式定义说的那样，命令模式对实现记录日志、撤销操作等功能比较方便。

*解释器模式--定义：给定一种语言，定义他的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中句子。

*迭代器模式--定义：提供一种方法访问一个容器对象中各个元素，而又不暴露该对象的内部细节。

迭代器模式的结构



抽象容器：一般是一个接口，提供一个iterator()方法，例如java中的Collection接口，List接口，Set接口等。

具体容器：就是抽象容器的具体实现类，比如List接口的有序列表实现ArrayList，List接口的链表实现LinkList，Set接口的哈希列表的实现HashSet等。

抽象迭代器：定义遍历元素所需要的方法，一般来说会有这么三个方法：取得第一个元素的方法first()，取得下一个元素的方法next()，判断是否遍历结束的方法isDone()（或者叫hasNext()），移出当前对象的方法remove(),

迭代器实现：实现迭代器接口中定义的方法，完成集合的迭代。

*中介者模式--定义：用一个中介者对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使耦合松散，而且可以独立地改变它们之间的交互。
中介者模式的结构

中介者模式又称为调停者模式，从类图中看，共分为3部分：

抽象中介者：定义好同事类对象到中介者对象的接口，用于各个同事类之间的通信。一般包括一个或几个抽象的事件方法，并由子类去实现。

中介者实现类：从抽象中介者继承而来，实现抽象中介者中定义的事件方法。从一个同事类接收消息，然后通过消息影响其他同时类。

同事类：如果一个对象会影响其他的对象，同时也会被其他对象影响，那么这两个对象称为同事类。在类图中，同事类只有一个，这其实是现实的省略，在实际应用中，同事类一般由多个组成，他们之间相互影响，相互依赖。同事类越多，关系越复杂。并且，同事类也可以表现为继承了同一个抽象类的一组实现组成。在中介者模式中，同事类之间必须通过中介者才能进行消息传递。

中介者模式的优点

1、适当地使用中介者模式可以避免同事类之间的过度耦合，使得各同事类之间可以相对独立地使用。

2、使用中介者模式可以将对象间一对多的关联转变为一对一的关联，使对象间的关系易于理解和维护。

3、使用中介者模式可以将对象的行为和协作进行抽象，能够比较灵活的处理对象间的相互作用。


*备忘录模式-定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态。

备忘录模式的结构

发起人：记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责**创建**和恢复备忘录数据。

备忘录：负责存储发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。

管理角色：对备忘录进行管理，保存和提供备忘录。

多状态多备份备忘录

 实现备忘录的方法很多，备忘录模式有很多变形和处理方式，像通用代码那样的方式一般不会用到，多数情况下的备忘录模式，是多状态多备份的。其实实现多状态多备份也很简单，
 最常用的方法是，我们在Memento中增加一个Map容器来存储所有的状态，在Caretaker类中同样使用一个Map容器才存储所有的备份。

*观察者模式-定义对象间一种一对多的依赖关系，使得当每一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。

观察者模式的结构

在最基础的观察者模式中，包括以下四个角色：

被观察者：从类图中可以看到，类中有一个用来存放观察者对象的Vector容器（之所以使用Vector而不使用List，是因为多线程操作时，Vector在是安全的，而List则是不安全的），
这个Vector容器是被观察者类的核心，另外还有三个方法：attach方法是向这个容器中添加观察者对象；detach方法是从容器中移除观察者对象；notify方法是依次调用观察者对象的对应方法。
这个角色可以是接口，也可以是抽象类或者具体的类，因为很多情况下会与其他的模式混用，所以使用抽象类的情况比较多。

观察者：观察者角色一般是一个接口，它只有一个update方法，在被观察者状态发生变化时，这个方法就会被触发调用。

具体的被观察者：使用这个角色是为了便于扩展，可以在此角色中定义具体的业务逻辑。

具体的观察者：观察者接口的具体实现，在这个角色中，将定义被观察者对象状态发生变化时所要处理的逻辑。

*状态模式-当系统中某个对象存在多个状态，这些状态之间可以进行转换，而且对象在不同状态下行为不相同时可以使用状态模式。
状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化。状态模式是一种对象行为型模式。

四、参与者

1>、AbstractState(抽象状态类):

        在抽象状态类中定义申明了不同状态下的行为抽象方法，而由子类(不同的状态子类)中实现不同的行为操作。

2>、ConcreteState(实现具体状态下行为的状态子类):

        抽象状态类的子类，每一个子类实现一个与环境类(Context)的一个状态相关的行为，每一个具体的状态类对应环境的一种具体状态，不同的具体状态其行为有所不同。

3>、Context(拥有状态对象的环境类):

        拥有状态属性，因环境的多样性，它可拥有不同的状态，且在不同状态下行为也不一样。在环境类中维护一个抽象的状态实例，这个实例定义当前环境的状态(setState()方法)，而将具体的状态行为分离出来由不同的状态子类去完成。


 状态模式中 关于状态的切换有两种不同的实现方式

    方式一：状态的改变/切换  在环境类中实现。  如上面的用例代码Context类中的checkState()方法。

/**
    * 检查环境状态:状态的改变/切换 在环境类中实现
    */
   private void checkState(){
       if(bill >= 0.00){
           setState(new ConcreteStateA());
       } else {
           setState(new ConcreteStateB());
       }
   }

2> 在具体的子类状态类中根据构造进来的context对象，通过调用context对象的属性值进行业务逻辑判断 进行状态的检查和切换。

如在 具体的状态子类ConcreteStateA.java类中：

/**
* 具体的状态子类A
* @author  lvzb.software@qq.com
*/
public class ConcreteStateA extends State {
   private Context ctx;

   public ConcreteStateA(Context context){
       ctx = context;
   }

   @Override
   public void Behavior() {
       // 状态A 的业务行为, 及当为该状态下时，能干什么
       // 如：手机在未欠费停机状态下, 能正常拨打电话
       System.out.println("手机在未欠费停机状态下, 能正常拨打电话");
       checkState();

   }

   /**
    * 检查状态 是否需要进行状态的转换<br/>
    * 状态的切换由具体状态子类中实现
    */
   private void checkState(){
       if (ctx.getBill() < 0.00) {
           ctx.setState(new ConcreteStateB(ctx));
       }
   }
}


*空对象模式-在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。
    //判断Book对象是否为空对象（Null Object）
    public boolean isNull();

*策略模式-定义一组算法，将每个算法都封装起来，并且使他们之间可以互换。
策略模式的结构

封装类：也叫上下文，对策略进行二次封装，目的是避免高层模块对策略的直接调用。

抽象策略：通常情况下为一个接口，当各个实现类中存在着重复的逻辑时，则使用抽象类来封装这部分公共的代码，此时，策略模式看上去更像是模版方法模式。

具体策略：具体策略角色通常由一组封装了算法的类来担任，这些类之间可以根据需要自由替换。

*模版方法模式--定义：定义一个操作中算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变算法的结构即可重定义该算法中的某些特定步骤。

模版方法模式的结构

       模版方法模式由一个抽象类和一个（或一组）实现类通过继承结构组成，抽象类中的方法分为三种：

抽象方法：父类中只声明但不加以实现，而是定义好规范，然后由它的子类去实现。

模版方法：由抽象类声明并加以实现。一般来说，模版方法调用抽象方法来完成主要的逻辑功能，并且，模版方法大多会定义为final类型，指明主要的逻辑功能在子类中不能被重写。

钩子方法：由抽象类声明并加以实现。但是子类可以去扩展，子类可以通过扩展钩子方法来影响模版方法的逻辑。

抽象类的任务是搭建逻辑的框架，通常由经验丰富的人员编写，因为抽象类的好坏直接决定了程序是否稳定性。

模版方法的优点及适用场景

       容易扩展。一般来说，抽象类中的模版方法是不易反生改变的部分，而抽象方法是容易反生变化的部分，因此通过增加实现类一般可以很容易实现功能的扩展，符合开闭原则。

       便于维护。对于模版方法模式来说，正是由于他们的主要逻辑相同，才使用了模版方法，假如不使用模版方法，任由这些相同的代码散乱的分布在不同的类中，维护起来是非常不方便的。

       比较灵活。因为有钩子方法，因此，子类的实现也可以影响父类中主逻辑的运行。但是，在灵活的同时，由于子类影响到了父类，违反了里氏替换原则，也会给程序带来风险。这就对抽象类的设计有了更高的要求。

       在多个子类拥有相同的方法，并且这些方法逻辑相同时，可以考虑使用模版方法模式。在程序的主框架相同，细节不同的场合下，也比较适合使用这种模式。


*访问者模式-封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。
抽象访问者：抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法中的参数定义哪些对象是可以被访问的。

访问者：实现抽象访问者所声明的方法，它影响到访问者访问到一个类后该干什么，要做什么事情。

抽象元素类：接口或者抽象类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义的。抽象元素一般有两类方法，一部分是本身的业务逻辑，另外就是允许接收哪类访问者来访问。

元素类：实现抽象元素类所声明的accept方法，通常都是visitor.visit(this)，基本上已经形成一种定式了。

结构对象：一个元素的容器，一般包含一个容纳多个不同类、不同接口的容器，如List、Set、Map等，在项目中一般很少抽象出这个角色。


访问者模式的优点

符合单一职责原则：凡是适用访问者模式的场景中，元素类中需要封装在访问者中的操作必定是与元素类本身关系不大且是易变的操作，使用访问者模式一方面符合单一职责原则，另一方面，因为被封装的操作通常来说都是易变的，所以当发生变化时，就可以在不改变元素类本身的前提下，实现对变化部分的扩展。

扩展性良好：元素类可以通过接受不同的访问者来实现对不同操作的扩展。



